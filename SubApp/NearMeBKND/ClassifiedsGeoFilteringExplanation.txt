Classifieds Endpoint: Geo-Filtering, Pagination, and Fast Response
===============================================================

1. Controller Layer (clf_Controller.java)
-----------------------------------------
- Endpoint: @GetMapping("/") public ResponseEntity<?> getClassifiedsInRadius(...)
- Process:
  1. Gets the user's location from user_locations using the X-User-ID header.
  2. Sets a radius (e.g., 15 km).
  3. Calculates offset for pagination: offset = page * size.
  4. Calls the service to get:
     - The total count of classifieds within the radius (countClassifiedsInRadius).
     - The paged list of classifieds within the radius (getClassifiedsInRadiusPaged).
  5. Maps each result to a response DTO (excluding heavy fields).
  6. Returns a response with:
     - data (list of classifieds for this page)
     - currentPage, size, count (number in this page), totalPages

2. Service Layer (ClassifiedService.java)
-----------------------------------------
- Delegates to the repository for both the count and the paged data:
  - getClassifiedsInRadiusPaged(userLat, userLon, radiusKm, size, offset)
  - countClassifiedsInRadius(userLat, userLon, radiusKm)

3. Repository Layer (ClassifiedRepository.java)
-----------------------------------------------
Geo-Filtering and Pagination:
- Bounding Box Optimization:
  - First, limits the search to a latitude/longitude bounding box (fast, uses indexes).
- Precise Distance Calculation:
  - Uses the Haversine formula in SQL to filter only classifieds within the exact radius.
- Pagination:
  - SQL LIMIT ? OFFSET ? ensures only the required page is fetched from the DB.

SQL Example for Paged Data:
---------------------------
SELECT *, (6371 * acos(
    cos(radians(?)) * cos(radians(latitude)) *
    cos(radians(longitude) - radians(?)) +
    sin(radians(?)) * sin(radians(latitude))
)) AS distance
FROM clf_classified
WHERE latitude IS NOT NULL AND longitude IS NOT NULL
  AND latitude BETWEEN ? AND ?
  AND longitude BETWEEN ? AND ?
  AND (6371 * acos(
    cos(radians(?)) * cos(radians(latitude)) *
    cos(radians(longitude) - radians(?)) +
    sin(radians(?)) * sin(radians(latitude))
  )) <= ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?

- Indexes:
  - Indexes on latitude, longitude, and created_at make the bounding box and ordering fast.

SQL Example for Count:
----------------------
SELECT COUNT(*) FROM (
    SELECT * FROM clf_classified 
    WHERE latitude IS NOT NULL AND longitude IS NOT NULL 
    AND (6371 * acos(
        cos(radians(?)) * cos(radians(latitude)) *
        cos(radians(longitude) - radians(?)) +
        sin(radians(?)) * sin(radians(latitude))
    )) <= ?
)

4. DTO Layer
------------
- ClassifiedDTO (or map) is used to return only the required fields to the client, making the response lightweight and fast.

5. Why Is It Fast?
------------------
- Database does the heavy lifting:
  - Filtering and pagination are done in SQL, not in Java.
- Bounding box reduces the number of rows for the Haversine calculation.
- Proper indexes on latitude, longitude, and created_at make queries efficient.
- Only the current page is loaded into memory.

6. Summary of Flow
------------------
1. User location is fetched.
2. Bounding box and Haversine filtering in SQL.
3. Pagination in SQL.
4. DTO mapping for clean, fast responses.
5. Indexes ensure queries are quick even with large datasets. 